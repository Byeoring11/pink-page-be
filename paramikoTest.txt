#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket
import select
import sys
import time
import paramiko

# --------------------------------------------------------------
# 1️⃣  연결·인증 정보 (본인 환경에 맞게 수정)
# --------------------------------------------------------------
HOST          = "172.19.10.143"          # 서버 IP 혹은 호스트명
PORT          = 22
USERNAME      = "c3100419"
PASSWORD      = "shinhan@4"              # 비밀번호가 없으면 None

# 실행하고 싶은 명령과, 종료를 트리거할 문자열
COMMAND       = "sh vmyp_postgresql_dat_ddts.sh 707035514"            # 예: 파일 내용 보기
STOP_PHRASE   = "[SUCC] PostgreSQL load data unload Process"

# --------------------------------------------------------------
# 2️⃣  헬퍼 : 로그 출력 (버퍼링 없이 즉시)
# --------------------------------------------------------------
def log(msg: str) -> None:
    print(msg, flush=True)

# --------------------------------------------------------------
# 3️⃣  실시간 스트리밍 인터랙티브 셸
# --------------------------------------------------------------
def run_interactive_shell(
    ssh_client: paramiko.SSHClient,
    command: str,
    stop_phrase: str,
    recv_timeout: float = 0.1,
) -> None:
    """
    1) PTY‑쉘을 열고
    2) `command` 를 전송
    3) 출력이 실시간으로 터미널에 표시되며,
       `stop_phrase` 가 한 줄에 나타나면 셸을 종료한다.
    """
    transport = ssh_client.get_transport()
    channel   = transport.open_session()
    channel.get_pty()          # PTY 요청 → 대부분의 쉘이 정상 동작
    channel.invoke_shell()     # 인터랙티브 셸 시작
    log("[INFO] 인터랙티브 셸 열림")

    # 로그인 직후 프롬프트가 나올 때까지 버퍼 비우기
    time.sleep(0.3)
    while channel.recv_ready():
        channel.recv(1024)

    # ① 명령 전송
    channel.send(command + "\n")
    log(f"[CMD] {command}")

    # ② 실시간 출력 루프
    partial_line = b""
    while True:
        # 채널이 닫혔는지 확인
        if channel.closed:
            log("[WARN] 서버가 채널을 닫았습니다.")
            break

        # 읽을 수 있을 때만 recv (CPU 0% 수준)
        rlist, _, _ = select.select([channel], [], [], recv_timeout)
        if channel not in rlist:
            continue

        data = channel.recv(4096)
        if not data:                     # 0 바이트 → EOF
            log("[INFO] 서버가 EOF 를 보냈습니다.")
            break

        # 화면에 바로 출력 (바이트 그대로)
        sys.stdout.buffer.write(data)
        sys.stdout.flush()

        # 라인 단위로 stop_phrase 검사
        partial_line += data
        if b'\n' in partial_line:
            lines = partial_line.split(b'\n')
            partial_line = lines.pop()          # 아직 완전하지 않은 마지막 조각 보관
            for raw in lines:
                # 색 코드(ANSI escape) 제거 → 순수 텍스트만 비교
                txt = raw.decode(errors="replace")
                txt = txt.replace('\r', '')      # Windows‑style CR 제거
                if stop_phrase in txt:
                    log(f"\n[INFO] 종료 문자열 발견 → {stop_phrase}")
                    channel.send("exit\n")
                    # 남은 데이터 모두 출력하고 종료
                    while channel.recv_ready():
                        sys.stdout.buffer.write(channel.recv(4096))
                    channel.close()
                    return

    channel.close()
    log("[INFO] 인터랙티브 셸 루프 종료")

# --------------------------------------------------------------
# 4️⃣  메인 : 연결 → 인증 → 인터랙티브 셸 실행
# --------------------------------------------------------------
def main() -> None:
    # ---------- TCP 연결 ----------
    try:
        sock = socket.create_connection((HOST, PORT), timeout=10)
        log("[STEP] TCP 연결 성공")
    except Exception as exc:
        log(f"[ERROR] TCP 연결 실패: {exc}")
        sys.exit(1)

    # ---------- Transport 초기화 ----------
    try:
        transport = paramiko.Transport(sock)
        transport.start_client()               # 키 교환·버전 교환
        log("[STEP] KEX 완료")
    except Exception as exc:
        log(f"[ERROR] Transport 초기화 실패: {exc}")
        sys.exit(1)

    # ---------- 인증 (none → password fallback) ----------
    authenticated = False
    try:
        transport.auth_none(USERNAME)
        if transport.is_authenticated():
            log("[AUTH] none 인증 성공")
            authenticated = True
    except paramiko.AuthenticationException:
        log("[AUTH] none 인증 불가")
    except Exception as exc:
        log(f"[AUTH] none 인증 중 예외: {exc}")

    if not authenticated and PASSWORD:
        try:
            transport.auth_password(USERNAME, PASSWORD)
            if transport.is_authenticated():
                log("[AUTH] password 인증 성공")
                authenticated = True
        except paramiko.AuthenticationException:
            log("[AUTH] password 인증 실패")
        except Exception as exc:
            log(f"[AUTH] password 인증 중 예외: {exc}")

    if not authenticated:
        log("[FAIL] 모든 인증 시도 실패")
        transport.close()
        sys.exit(1)

    # ---------- SSHClient 재활용 ----------
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh_client._transport = transport   # 이미 인증된 Transport 사용

    # ---------- 인터랙티브 셸 실행 ----------
    try:
        run_interactive_shell(
            ssh_client,
            command=COMMAND,
            stop_phrase=STOP_PHRASE,
            recv_timeout=0.1,
        )
    except KeyboardInterrupt:
        log("\n[INFO] 사용자가 Ctrl‑C 로 중단")
    except Exception as exc:
        log(f"[ERROR] 인터랙티브 셸 실행 중 예외: {exc}")
    finally:
        ssh_client.close()               # 내부적으로 transport.close() 도 호출
        log("[INFO] SSH 연결 종료")

# --------------------------------------------------------------
if __name__ == "__main__":
    main()